      SUBROUTINE VBOUND(FT,IFT,JFT,IJV,LIJV)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C                .      .    .                                       .
C SUBPROGRAM:   PGM-VBOUND  CHECKING THE BOUNDARY POINTS
C   PRGMMR: KRISHNA KUMAR            ORG: W/NP12  DATE: 1999-08-01
C
C ABSTRACT: FINDING THE BOUNDARY POINTS
C
C PROGRAM HISTORY LOG:
C   86-04-24  ORIG AUTHOR  SCHNURR
C   90-03-15  LILLY ADD DOCBLOCK TO SUBROUTINE
C   93-06-01  GILBERT/LILLY FORTRAN 77
C   96-07-18  YEN - CONVERT FROM HDS VS FORTRAN TO CRAY CFT-77
C 1999-08-01  KRISHNA KUMAR CONVERTED THIS CODE FROM CRAY TO IBM RS/6000.
C                           ASSIGNED PROPER VALUE TO XINDEFF
C                           USING RANGE FUNCTION FOR IBM RS/6000 FOR
C                           COMPILE OPTIONS xlf -qintsize=8 -qrealsize=8.
C
C USAGE:     CALL VBOUND(FT,IFT,JFT,IJV,LIJV)
C   INPUT ARGUMENT LIST:
C     FT    - THE GIVEN ARRAY WITH INDEFINITES
C           - OUTSIDE THE BOUNDARIES
C     IFT   - THE I COORDINATE OF THE FIELD
C     JFT   - THE J COORDINATE OF THE FIELD
C     IJV   - THE DIMENSIONED 4XLIJV.  WORD ONE CONTAINS
C           - THE MARKER, WORD TWO THE I COMPONENT,
C           - WORD THREE THE J COMPONENT, AND WORD
C           - FOUR THE COUNT.  THE MARKER IS 0 FOR J
C           - VECTORS AND 1 FOR I VECTORS
C
C   OUTPUT ARGUMENT LIST:
C     LIJV  - DATA SET REF NUMBER OF TEMPORARY DISK FILE TO
C           - WRITE THE ARGS ONTO
C
C   SUBPROGRAMS CALLED:
C     LIBRARY:
C       SPECIAL  -
C       W3LIB    -
C       GRAPHICS -
C
C   EXIT STATES:
C     COND =   0   SUCCESSFUL RUN
C          =1001   IJV ARRAY TOO SHORT
C
C   REMARKS: ADDITIONAL INFORMATION WILL BE PROVIDED AS PROGRAM
C    BECOMES BETTER UNDERSTOOD
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  IBM
C
C$$$
C
C
C     ...FT IS THE GIVEN ARRAY WITH INDEFINITES OUTSIDE THE BOUNDARIES
C     ...IFT,JFT ARE THE DIMENSIONS OF FT
C     ...IJV IS DIMENSIONED 4XLIJV.  WORD ONE CONTAINS
C     ...THE MARKER, WORD TWO THE I COMPONENT, WORD THREE THE J
C     ...COMPONENT, AND WORD FOUR THE COUNT.  THE MARKER IS 0 FOR J
C     ...VECTORS AND 1 FOR I VECTORS.
C
C
      DIMENSION FT(IFT,JFT)
      DIMENSION IJV(4,LIJV)
      REAL     XINDEF
      DATA    XINDEF   /1.0E307 /
C     ...ZERO LOCATIONS OF IJV
      DO 10 M=1,LIJV
      DO 20 N=1,4
      IJV(N,M)=0
   20 CONTINUE
   10 CONTINUE
C     ...SCAN FT ARRAY FOR ALL BOUNDARY PTS AND FLAG THE POINT WITH 1
      DO 60 IP=1,IFT
      DO 60 JP=1,JFT
      IF(FT(IP,JP).EQ.XINDEF) GO TO 60
      IF((IP.EQ.1).OR.(IP.EQ.IFT)) GO TO 35
      IF((JP.EQ.1).OR.(JP.EQ.JFT)) GO TO 35
      GO TO 50
   35 CONTINUE
C     ...POINT IS ON THE BOUNDARY OF FT ARRAY AND NOT INDEFINITE
   40 FT(IP,JP)=1.0
C     ...POINT IS ON THE BOUNDARY NEXT TO AN INDEFINITE
      GO TO 60
C     ...CHECK IF POINT IS A CORNER PT. OF AN ADJACENT SQUARE WHICH
C     ...HAS AT LEAST ONE INDEFINITE CORNER PT.
   50 CONTINUE
      IF(FT(IP-1,JP-1).EQ.XINDEF) GO TO 40
      IF(FT(IP-1,JP).EQ.XINDEF) GO TO 40
      IF(FT(IP-1,JP+1).EQ.XINDEF) GO TO 40
      IF(FT(IP,JP-1).EQ.XINDEF) GO TO 40
      IF(FT(IP,JP+1).EQ.XINDEF) GO TO 40
      IF(FT(IP+1,JP-1).EQ.XINDEF) GO TO 40
      IF(FT(IP+1,JP).EQ.XINDEF) GO TO 40
      IF(FT(IP+1,JP+1).EQ.XINDEF) GO TO 40
C     ...POINT IS IN THE INTERIOR
      FT(IP,JP)=0
   60 CONTINUE
C     ...SCAN FIELD FOR J THEN I LINE SEGMENTS AND PUT IN IJV ARRAY
      K=1
C     ...J-VECTOR SEARCH
      MRK=0
      DO 100 IP=1,IFT
      KNT=0
      ISAV=IP
      DO 90 JP=1,JFT
      IF(FT(IP,JP).EQ.XINDEF) GO TO 70
      IF(FT(IP,JP).NE.1.) GO TO 70
      IF(KNT.NE.0) GO TO 66
      JSAV=JP
      KNT=KNT+1
      GO TO 90
   66 CONTINUE
      KNT=KNT+1
C     ...CHECK IF ADJACENT POINT IN NEXT ROW IS A BOUNDARY POINT
      IF((IP.EQ.1).OR.(IP.EQ.IFT)) GO TO 90
      IF(FT(IP+1,JP).EQ.XINDEF) GO TO 90
      IF(FT(IP-1,JP).EQ.XINDEF) GO TO 90
      IF(FT(IP+1,JP).EQ.1.) GO TO 70
C     ...POINT TO THE RIGHT IS IN THE INTERIOR
      GO TO 90
   70 IF(KNT.GT.1) GO TO 80
      KNT=0
      GO TO 90
   80 IF(K.GT.(LIJV-1)) GO TO 1000
      IJV(1,K)=MRK
      IJV(2,K)=ISAV
      IJV(3,K)=JSAV
      IJV(4,K)=KNT
      K=K+1
      KNT=0
   90 CONTINUE
  100 CONTINUE
C     ...I-VECTOR SEARCH
      MRK=1
      DO 200 JP=1,JFT
      KNT=0
      JSAV=JP
      DO 190 IP=1,IFT
      IF(FT(IP,JP).EQ.XINDEF) GO TO 170
      IF(FT(IP,JP).NE.1.) GO TO 170
      IF(KNT.NE.0) GO TO 166
      ISAV=IP
      KNT=KNT+1
      GO TO 190
  166 CONTINUE
      KNT=KNT+1
C     ...CHECK IF ADJACENT POINT IN NEXT ROW IS A BOUNDARY POINT
      IF((JP.EQ.1).OR.(JP.EQ.JFT)) GO TO 190
      IF(FT(IP,JP+1).EQ.XINDEF) GO TO 190
      IF(FT(IP,JP-1).EQ.XINDEF) GO TO 190
      IF(FT(IP,JP-1).NE.1.) GO TO 190
C     ...POINT BELOW IS ON BOUNDARY. STOP COUNT.
      GO TO 170
  170 IF(KNT.GT.1) GO TO 180
      KNT=0
      GO TO 190
  180 IF(K.GT.(LIJV-1)) GO TO 1000
      IJV(1,K)=MRK
      IJV(2,K)=ISAV
      IJV(3,K)=JSAV
      IJV(4,K)=KNT
      K=K+1
      KNT=0
  190 CONTINUE
  200 CONTINUE
      RETURN
 1000 PRINT 1001
 1001 FORMAT(5X,'IJV ARRAY TOO SHORT')
      RETURN
      END
