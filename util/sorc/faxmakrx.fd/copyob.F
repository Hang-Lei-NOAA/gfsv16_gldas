      SUBROUTINE COPYOB(LOBTAP,INBIN,ILVLT,KRUN1,IDATG,IOPTRA,
     1                  KOUNT,IERROR)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C                .      .    .                                       .
C SUBPROGRAM:    COPYOB      DESCRIPTIVE TITLE NOT PAST COL 70
C   PRGMMR: KRISHNA KUMAR         ORG: W/NP12   DATE: 1999-08-01
C
C ABSTRACT: DOCUMENTATION WILL BE ADDED LATER.
C
C PROGRAM HISTORY LOG:
C   ??-??-??  DICK SCHURR
C   93-04-07  LILLY         CONVERT SUBROUTINE TO FORTRAN 77
C   98-06-03  FACEY         Y2K CONVERSION; USE OF 4 DIGIT YEAR 
C                           2 DIGIT YEAR STILL USED TO GET OBS
C 1999-08-01  KRISHNA KUMAR CONVERTED THIS CODE FROM CRAY TO IBM
C                           RS/6000. ADDED A BLOCK DATA TO RUN 
C                           ON IBM RS/6000 SP SYSTEM.
C
C USAGE:    CALL COPYOB( LOBTAP, INBIN, ILVLT, KRUN1, IDATG, IOPTRA,
C                        NOPTINS, KOUNT, IERROR )
C   INPUT ARGUMENT LIST:
C     INARG1   - GENERIC DESCRIPTION, INCLUDING CONTENT, UNITS,
C     INARG2   - TYPE.  EXPLAIN FUNCTION IF CONTROL VARIABLE.
C
C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
C     WRKARG   - GENERIC DESCRIPTION, ETC., AS ABOVE.
C     OUTARG1  - EXPLAIN COMPLETELY IF ERROR RETURN
C     ERRFLAG  - EVEN IF MANY LINES ARE NEEDED
C
C   INPUT FILES:   (DELETE IF NO INPUT FILES IN SUBPROGRAM)
C     DDNAME1  - GENERIC NAME & CONTENT
C
C   OUTPUT FILES:  (DELETE IF NO OUTPUT FILES IN SUBPROGRAM)
C     DDNAME2  - GENERIC NAME & CONTENT AS ABOVE
C     FT06F001 - INCLUDE IF ANY PRINTOUT
C
C REMARKS: LIST CAVEATS, OTHER HELPFUL HINTS OR INFORMATION
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  IBM
C
C$$$
C
C     THIS SUBROUTINE WAS MODIFIED TO REMOVE ALL ASYNCHRONOUS I/O.
C     - 5/29/86 (DKM)
C
C     (1) LOBTAP ... DATA SET REF. NO. OF INPUT TAPE WHERE PLOTTED OBS
C                  ARE IN LABEL-ARRAY FORMAT LIKE TAPE55.
C     (2) INBIN ...SCRATCH AREA FOR INPUT BUFFER  OF 2048 WORDS.
C     (3) ILVLT ... AN INDEX TO THE LEVEL DESIRED
C     (4) KRUN1 ... AN INDEX TO THE RUN TYPE.
C     (5) IDATG(4). GIVEN DATE TIME GROUP
C                  /YR/MO/DA/HR/  ONE WORD  BYTE EACH.
C     (6),(7) IOPTRA(2) ... ARRAY FOR ADDITIONAL OPTIONS...
C                  IOPTRA(1) NON ZERO IF BYPASSING DATE-TIME COMPARE
C                  IOPTRA(2) = NON-ZERO IF BYPASSING BACKRND COMPARE
C     (8) KOUNT ... COUNT OF LABEL ARRAY ITEMS WHICH WERE COPIED
C     (9) IERROR ..=0 FOR NORMAL END
C                  =1 GIVEN ARGUMENT OUT OF RANGE
C                  =2 READ ERROR BEFORE FINDING MATCHING DATA FIELD
C                  =3 ABNORMAL END TO INPUT FILE. NO DATA TRANSFERRED
C                  =4 LOOKED LIKE A NORMAL END BUT NO DATA TRANSFERRED
C                  =5ABNORMAL END AFTER SOME DATA WAS TRANSFERRED
C     ...CAUTION...COPYOB NEITHER OPENS NOR CLOSES THE LBLTAP TAPE55,
C     ...   IT SIMPLY ADDS ONTO IT AND LEAVES IT OPEN AT RETURN,
C     ...   THEREBY PERMITTING THE MAIN PROGRAM TO ADD OTHER LABEL ARRAY
C     ...   ITEMS.
C     *     *     *     *     *     *     *     *     *     *     *
C
      COMMON  /KPLOT/ LABEL(2,1024),LABIX,NOBUF,IDRA(50)
C
      INTEGER     KROT_PRI(2),ICMD,IPT,JPT,NCHAR
      REAL        HEIGHT,ANGLE
      CHARACTER*4 CTEXT
C
C     -----------------------------------------------------------------
C
      INTEGER      MAXFONT
      PARAMETER   (MAXFONT=63)
C
      COMMON /PUTWHERE/ LBLTAP,IERPUT,LCKPT_PUT,LCKPRNQQ,
     1                  IJPXL_GIVN(2),IJPXL_LBL(2),IJPXL_NEXCH(2),
     2                  NCALLS_PUT,ICOUNT_FONT(MAXFONT)

C
      DIMENSION  IDATG(4)
      DIMENSION  IDBUFF(128)
      DIMENSION  JDBUFF(64)
      DIMENSION  IOPTRA(2)
      DIMENSION  INBIN(2,1024)
      DIMENSION  INBUF(1024)
      DIMENSION  IBCD(2)
      DIMENSION  IHDTG(3),KHDTG(3)
      DIMENSION KHMBS(2,29)
      DIMENSION KHRUN(4,23)
      DIMENSION  NAMLVL(2)
      DIMENSION  NAMRUN(2)
      DIMENSION  NAMBKG(2)
      DIMENSION  KHIQSY(2)
C
      INTEGER    LEND
C
      CHARACTER*8  MIBCD
C     CHARACTER*1  LBYTE(8)
C
      REAL*8  DBLWRD
C
      LOGICAL    LBKCHK,LDACHK
C
      DATA    KHMBS/4HSURF, 4HACE , 4H1000, 4HMB  ,
     1              4H850M, 4HB   , 4H700M, 4HB   ,
     2              4H500M, 4HB   , 4H400M, 4HB   ,
     3              4H300M, 4HB   , 4H250M, 4HB   ,
     4              4H200M, 4HB   , 4H150M, 4HB   ,
     5              4H100M, 4HB   , 4H70MB, 4H    ,
     6              4H50MB, 4H    , 4H30MB, 4H    ,
     7              4H20MB, 4H    , 4H10MB, 4H    ,
     8              4H7MB , 4H    , 4H5MB , 4H    ,
     9              4H3MB , 4H    , 4H2MB , 4H    ,
     A              4H1MB , 4H    , 4H0.4M, 4HB   ,
     B              4HTROP, 4HO   , 4HSIGL, 4H    ,
     C              4HFRZG, 4H LVL, 4HREL , 4HHUM ,
     D              4H  IN, 4HDEX , 4HPREC, 4HIP-W,
     E              4HSFC , 4HANAL/
C     ...WHERE KHMBS IS SEQUENCED ACCORDING TO ILVLT
      DATA KHRUN/4HRADA,4HT   ,4HNH40,4H04  ,4HOPNL,4H    ,4HNH40,4H04 ,
     1,         4HOVR4,4H8OPN,4HNH40,4H04  ,4HFINA,4HL   ,4HNH40,4H04  ,
C    2          4HLFM ,4H    ,4HNH25,4H01  ,4HPFAX,4H    ,4HNH40,4H053 ,
     2          4HTRAJ,4HFAX ,4HNH25,4H01  ,4HPFAX,4H    ,4HNH40,4H053 ,
     3          4HBKUP,4HPFAX,4HNH40,4H05  ,4H1DOT,4HFAX ,4HNH20,4H02  ,
     4          4H2DOT,4HFAX ,4HNH20,4H02  ,4HSIRS,4HPLOT,4HNH40,4H04  ,
     5          4HTROP,4HIC1 ,4HMR40,4H02  ,4HTROP,4HIC2 ,4HMR40,4H02  ,
     6          4HUS1P,4HLOT ,4HNH10,4H01  ,4HUABP,4HLOT ,4HNH40,4H04  ,
     7          4HNHEM,4HI20 ,4HNH20,4H03  ,4HWIND,4HPLOT,4HPN26,4H01  ,
     8          4HNHEM,4HI40 ,4HNH40,4H04  ,4HSHEM,4HI40 ,4HSH40,4H02  ,
     9          4HUABP,4HLOT ,4HNH60,4H01  ,4HRAOB,4H    ,4HNH25,4H01  ,
     X          4HSFC ,4HPLOT,4HNH20,4H05  ,4HGOES,4HPLOT,4HGH26,4H01  ,
     Y          4HGOES,4HPLOT,4HGH26,4H02  /
C     ...WHERE KHRUN IS SEQUENCED ACCORDING TO KRUN1...
C
      DATA     KHIQSY/4HUABP,4HLOT  /
      DATA     KHDTG/4HMM/D, 4HD/YY, 4H GGZ/
      DATA     K000Z/Z'000000E9'/
      DATA     IQSYL1/11/
      DATA     IQSYL2/16/
ckumar      DATA     LBLTAP/55/
      DATA     LEND/8H    LEND/
      DATA     LMAX/1024/
      DATA MXMBS/29/
      DATA MXRUNS/23/
C
      DATA     MSK0F /Z'00000000FFFFFFFF'/
C
      EQUIVALENCE(MIBCD,IBCD(1))
#if defined (_LITTLE_ENDIAN)
      LOGICAL FIRST_ENTRY
      DATA FIRST_ENTRY/.TRUE./
      IF (FIRST_ENTRY) THEN
        CALL SWAP_BYTES_IN_PLACE (LEND, 8_8, 1_8)
        FIRST_ENTRY = .FALSE.
      ENDIF
#endif
C
C     ...STEP(1) ... INITIALIZATION ...
      KOUNT = 0
      IERROR = 0
      NUMRED = 0
      NUMIDR = 0
      NUMTRN = 0
C
      LABXSV = LABIX
      NOBFSV = NOBUF
      LBKCHK = .TRUE.
      IF(IOPTRA(2) .NE. 0) LBKCHK=.FALSE.
C     ...FROM GIVEN ILVLT,KRUN1,IDATG GENERATE IDENTIFIERS FOR SEARCH
      IF(ILVLT .LT. 1) GO TO 810
      IF(ILVLT .GT. MXMBS) GO TO 810
C     NAMLVL(1) = KHMBS(1,ILVLT)
C     NAMLVL(2) = KHMBS(2,ILVLT)
#if defined (_LITTLE_ENDIAN)
      NAMLVL(1) = ISHFT (IAND (KHMBS(1,ILVLT),MSK0F),32)
      NAMLVL(2) = ISHFT (IAND (KHMBS(2,ILVLT),MSK0F),32)
#else
      NAMLVL(1) = ISHFT(KHMBS(1,ILVLT),-32)
      NAMLVL(2) = ISHFT(KHMBS(2,ILVLT),-32)
#endif
C
      PRINT *,' ILVLT=',ILVLT
      PRINT *,' NAME LVL='
      PRINT 119, NAMLVL(1),NAMLVL(2)  
C
      IF(KRUN1 .LT. 1) GO TO 820
      IF(KRUN1 .GT. MXRUNS) GO TO 820
#if defined (_LITTLE_ENDIAN)
      NAMRUN(1) = ISHFT (IAND (KHRUN(1,KRUN1),MSK0F),32)
      NAMRUN(2) = ISHFT (IAND (KHRUN(2,KRUN1),MSK0F),32)
      NAMBKG(1) = ISHFT (IAND (KHRUN(3,KRUN1),MSK0F),32)
      NAMBKG(2) = ISHFT (IAND (KHRUN(4,KRUN1),MSK0F),32)
#else
      NAMRUN(1) = ISHFT(KHRUN(1,KRUN1),-32)
      NAMRUN(2) = ISHFT(KHRUN(2,KRUN1),-32)
      NAMBKG(1) = ISHFT(KHRUN(3,KRUN1),-32)
      NAMBKG(2) = ISHFT(KHRUN(4,KRUN1),-32)
#endif
      IF(ILVLT .LT. IQSYL1) GO TO 155
      IF(ILVLT .GT. IQSYL2) GO TO 155
      IF(KRUN1 .NE. 4) GO TO 155
C     ...OTHERWISE, THIS IS IQSY UABPLOT DESIRED...
      NAMRUN(1) = ISHFT(KHIQSY(1),-32)
      NAMRUN(2) = ISHFT(KHIQSY(2),-32)
  155 CONTINUE
C     NAMLVL(1) = KHMBS(1,ILVLT)
C     NAMLVL(2) = KHMBS(2,ILVLT)
#if defined (_LITTLE_ENDIAN)
      NAMLVL(1) = ISHFT( IAND(KHMBS(1,ILVLT),MSK0F),32)
      NAMLVL(2) = ISHFT( IAND(KHMBS(2,ILVLT),MSK0F),32)
#else
      NAMLVL(1) = ISHFT(KHMBS(1,ILVLT),-32)
      NAMLVL(2) = ISHFT(KHMBS(2,ILVLT),-32)
#endif
C     ...NOW NAMLVL HAS '850MB   ', NAMRUN HAS '1DOTFAX',
C     ...    NAMBKG HAS 'NH2002  ', FOR EXAMPLE.
C     ...I STILL NEED THE DATE/TIME...
      DO  166  I=1,3
      IHDTG(I) = KHDTG(I)
  166 CONTINUE
      NYR = IDATG(1)
      NMO = IDATG(2)
      NDA = IDATG(3)
      NHR = IDATG(4)
      LDACHK = .TRUE.
      IF(IOPTRA(1) .EQ. 0) GO TO 170
C     ...OTHERWISE, IOPTRA(1) IS NON-ZERO FOR BYPASSING DATE COMPARISON
      LDACHK = .FALSE.
      GO TO 180
  170 CONTINUE
      CALL DAYOWK(NDA,NMO,NYR,IDAYWK,IHDAYW)
      NYR = NYR - (NYR/100)*100
      IF(IDAYWK .NE. 0) GO TO 178
C     ...OTHERWISE, GIVEN DATE INFO OUT OF RANGE
      PRINT  174, IDATG
  174 FORMAT(1H0, 10X, '***IMPOSSIBLE DATE GIVEN TO SUBR COPYOB IN IDATG
     1 = HEX ', Z8)
C     ...CONTINUE WITHOUT DATE-CHECKING...
      LDACHK = .FALSE.
      GO TO 180
  178 CONTINUE
C     ...REFORMAT DATE/TIME TO EBCDIC CHARACTERS...
      CALL BIN2EB(NMO,MIBCD,2,'L999')
      IHDTG(1) = IBCD(1)
      CALL BIN2EB(NDA,MIBCD,3,'L///')
      IHOLDD = ISHFT(IBCD(1),-16)
      IHDTG(1) = IOR(IHDTG(1),IHOLDD)
      IHDTG(2) = ISHFT(IBCD(1),16)
      CALL BIN2EB(NYR,MIBCD,3,'L///')
      IHOLDY = ISHFT(IBCD(1),-8)
      IHDTG(2) = IOR(IHDTG(2),IHOLDY)
      CALL BIN2EB(NHR,MIBCD,3,'L   ')
      IHDTG(3) = IOR (IBCD(1),K000Z)
  180 CONTINUE
      PRINT  184,(IHDTG(I),I=1,3),(NAMLVL(J),J=1,2),
     1          (NAMRUN(K),K=1,2), (NAMBKG(KK),KK=1,2)
  184 FORMAT(1H , 10X, 'REQUESTED COPY OF PLOTTED OBSERVATIONS FOR ',
     1       3A4, 4X, 2A4, 2A4, 8X, 2A4)
C     *     *     *     *     *     *     *     *     *     *     *
C     ...STEP(2) ... SEARCH THE LOBTAP FOR THE MATCHING FILE...
      PRINT *,' LOBTAP=', LOBTAP
#if defined (_LITTLE_ENDIAN)
      CALL SWAP_BYTES_IN_PLACE (IHDTG,  8_8, 3_8)
      CALL SWAP_BYTES_IN_PLACE (NAMLVL, 8_8, 2_8)
      CALL SWAP_BYTES_IN_PLACE (NAMRUN, 8_8, 2_8)
      CALL SWAP_BYTES_IN_PLACE (NAMBKG, 8_8, 2_8)
#endif
      REWIND LOBTAP
  211 CONTINUE
      NUMRED = NUMRED + 1
C     ...CHANGED FROM ASYNC READ 5/29/86 (DKM)...
C      WRITE (*,*) 'FPDebug: 1: attempting to read 512 bytes'
      READ(LOBTAP,ERR=920,END=910)JDBUFF
C     ...WHICH ALSO POSITIONS LOBTAP TO DATA BINS
      CALL GBYTES(JDBUFF,IDBUFF,0,32,0,128)
C     DO I=1,128
C         IDBUFF(I) = IAND(MSK0F,IDBUFF(I))
C     ENDDO
  245 CONTINUE
C     ...IT WAS A GOOD READ, BUT WAS IT A LOGICAL ENDOF FILE QQ
      PRINT *, ' JDBUFF(1)='
      PRINT 119,JDBUFF(1),JDBUFF(2)
      PRINT *, ' IDBUFF(1),(2)='
      PRINT 119,IDBUFF(1),IDBUFF(2)
      PRINT 119,IDBUFF(3),IDBUFF(4)
  119 FORMAT(1H ,Z16,5X,Z16)
      ITEMP = IAND(MSK0F, -7)
C     IF(IDBUFF(1) .NE. -7) GO TO 250
      IF(IDBUFF(1) .NE. ITEMP) GO TO 250
      ITEMP = IAND(MSK0F, LEND)
C     IF(IDBUFF(2) .EQ. LEND) GO TO 930
      IF(IDBUFF(2) .EQ. ITEMP) GO TO 930
C     ...WHICH IS EMPTY LOGICAL FILE OR DBL LOGICAL EOFS
  250 CONTINUE
      ITEMP = IAND(MSK0F, -1)
C     IF(IDBUFF(1) .NE. -1) GO TO 940
      IF(IDBUFF(1) .NE. ITEMP) GO TO 940
C     ...WHICH ERROR EXITS IF NOT ID RECORD FLAG
C     ...OTHERWISE, ASSUME A GOOD IDREC IN ...
      PRINT *, ' GET A IDREC'
      NUMIDR = NUMIDR + 1
      PRINT *, ' NAMLVL='
      PRINT 119, NAMLVL(1),NAMLVL(2)
      PRINT 119, IDBUFF(9),IDBUFF(10)
      IF(IDBUFF(9) .NE. NAMLVL(1)) GO TO 280
      IF(IDBUFF(10) .NE. NAMLVL(2)) GO TO 280
      PRINT *, ' NOT GO TO 280-1'
C     ...OTHERWISE, FOUND A MATCHING LEVEL. NEXT TEST RUN TYPE
      PRINT *, ' NAMRUN='
      PRINT 119, NAMRUN(1),NAMRUN(2)
      PRINT 119, IDBUFF(11),IDBUFF(12)
      IF(IDBUFF(11) .NE. NAMRUN(1)) GO TO 280
      IF(IDBUFF(12) .NE. NAMRUN(2)) GO TO 280
      PRINT *, ' NOT GO TO 280-2'
C     ...OTHERWISE, FOUND A MATCHING RUN TYPE...
      IF(.NOT. LBKCHK) GO TO 260
      PRINT *, ' NAMBKG='
      PRINT 119, NAMBKG(1),NAMBKG(2)
      PRINT 119, IDBUFF(15),IDBUFF(16)
      IF(IDBUFF(15) .NE. NAMBKG(1)) GO TO 280
      IF(IDBUFF(16) .NE. NAMBKG(2)) GO TO 280
      PRINT *, ' NOT GO TO 280-3'
C     ...OTHERWISE,  BACKGROUND MATCHES...
  260 CONTINUE
      IF(.NOT. LDACHK) GO TO 270
      PRINT *, ' IHDTGG='
      PRINT 119, IHDTG(1),IHDTG(2)
      PRINT 119, IDBUFF(5),IDBUFF(6)
      IF(IDBUFF(5) .NE. IHDTG(1)) GO TO 280
      IF(IDBUFF(6) .NE. IHDTG(2)) GO TO 280
      IF(IDBUFF(7) .NE. IHDTG(3)) GO TO 280
      PRINT *, ' NOT GO TO 280-4'
C     ...OTHERWISE, FOUND MATCHING DATE-TIME GROUP
  270 CONTINUE
      GO TO 300
C     *     *     *     *     *     *     *     *     *     *     *
C     ...COMES HERE IF THIS IDBUFF DID NOT MATCH THE DESIRED ONE,
C     ...   SO MUST SPACE OVER THE DATA BINS OF THIS LOGICAL FILE...
  280 CONTINUE
      NUMRED = NUMRED +1
C      WRITE (*,*) 'FPDebug: 2: attempting to read 8192 bytes'
      READ(LOBTAP,ERR=920,END=910) INBUF
      CALL GBYTES(INBUF,INBIN,0,32,0,2048)
C     DO I=1,1024
C         INBIN(1,I) = IAND(MSK0F,INBIN(1,I))
C         INBIN(2,I) = IAND(MSK0F,INBIN(2,I))
C     ENDDO
  285 CONTINUE
C     ...IT WAS A GOOD READ, BUT IS IT A LOGICAL END OF FILE QQ
      PRINT *, ' INBUF(1,1)='
      PRINT 119,INBUF(1),INBUF(2)
      PRINT *, ' INBIN(2,1)='
      PRINT 119,INBIN(1,1),INBIN(2,1)
      PRINT 119,INBIN(1,2),INBIN(2,2)
      ITEMP = IAND(MSK0F, -7)
C     IF(INBIN(1,1) .NE. -7) GO TO 287
      PRINT 119,INBIN(1,1),INBIN(2,1)
      IF(INBIN(1,1) .NE. ITEMP) GO TO 287
      PRINT *, ' IT IS A -7   RECORD'
      ITEMP = IAND(MSK0F, LEND)
      PRINT 119,INBIN(2,1),INBIN(2,2)
      PRINT 119,LEND,ITEMP
C     IF(INBIN(2,1) .EQ. LEND) GO TO 290
      IF(INBIN(2,1) .EQ. ITEMP) GO TO 290
C     ...IT WAS NOT A LOGICAL END OF FILE...
  287 CONTINUE
      PRINT *, ' IT IS A GOOD RECORD'
      ITEMP = IAND(MSK0F, -1)
C     IF(INBIN(1,1) .EQ. -1) GO TO 940
      IF(INBIN(1,1) .EQ. ITEMP) GO TO 940
      PRINT *, ' IT IS A GOOD RECORD'
C     ...WHICH IS ERROR EXIT. HIT ID REC WHEN IT SHUD BE DATA RECORD
C     ...OTHERWISE, ASSUME IT WAS A DATA RECORD TO BE SKIPPED
      GO TO 280
  290 CONTINUE
      PRINT *, ' IT IS A -7   RECORD'
C     ...REACHED THE LOGICAL END OF FILE WHICH I WAS LOOKING FOR...
      GO TO 211
C
C     *     *     *     *     *     *     *     *     *     *     *
C     ...STEP(3) ... TO COPY THE INFO FROM THE MATCHING FILE
  300 CONTINUE
      IF (KRUN1.EQ.5) THEN 
C         ... THIS IS FOR TRAJ 4-PANEL LINE ELEMENT TAPE 54 INPUT
          PRINT *, ' RESET THE LABEL ARRAY'
          NOBUF = 0
          LABIX = 0
          DO  I = 1,LMAX
              LABEL(1,I) = 0
              LABEL(2,I) = 0
          ENDDO
C
          IPT = 1
          JPT = 0
          HEIGHT = 12.0
          ANGLE = 0.0
          KROT_PRI(1) = 0
          KROT_PRI(2) = 0
          CTEXT(1:1) = '?'
          CTEXT(2:2) = CHAR(12)
          CTEXT(3:3) = '$'
          CTEXT(4:4) = CHAR(0)
          NCHAR = 2
          ICMD = -2
          CALL PUTLAB(IPT,JPT,HEIGHT,CTEXT,ANGLE,NCHAR,KROT_PRI,
     X                ICMD)
C
      ENDIF
C
#if defined (_LITTLE_ENDIAN)
      CALL SWAP_BYTES_IN_PLACE (IDBUFF(3), 8_8, 14_8)
#endif
      PRINT  310, (IDBUFF(I),I=3,16),NUMIDR,NUMRED
#if defined (_LITTLE_ENDIAN)
      CALL SWAP_BYTES_IN_PLACE (IDBUFF(3), 8_8, 14_8)
#endif
  310 FORMAT(1H , 10X, 'SUBR COPYOB FOUND MATCHING IDENTIFIER FOR ',
     1       14A4, /1H , 15X, 'AFTER SEARCHING THRU', I3, 2X,
     2       'LOGICAL FILES OF ', I5, 2X, 'PHYSICAL RECORDS.')
      IF(LDACHK) GO TO 316
      PRINT  314
  314 FORMAT(1H , 20X, 'DATE/TIME COMPARISON WAS BYPASSED')
  316 CONTINUE
      IF(LBKCHK) GO TO 320
      PRINT  318
  318 FORMAT(1H ,20X,'BACKGROUND COMPARISON CHECK WAS BYPASSED')
C
  320 CONTINUE
C     ...TO READ AND TRANSFER LOBTAP DATA TO LABEL FILE...
C      WRITE (*,*) 'FPDebug: 3: attempting to read 8192 bytes'
      READ(LOBTAP,ERR=330,END=340)INBUF
      CALL GBYTES(INBUF,INBIN,0,32,0,2048)
C     DO I=1,1024
C         INBIN(1,I) = IAND(MSK0F,INBIN(1,I))
C         INBIN(2,I) = IAND(MSK0F,INBIN(2,I))
C     ENDDO
      GO TO 360
  330 CONTINUE
C     ...COMES HERE IF PARITY ERROR WHILE READING DATA
      IF(KOUNT .EQ. 0) GO TO 336
C     ...COMES HERE IF SOME INFO HAS ALREADY PASSED BEFORE ERROR
      PRINT  333, LOBTAP,KOUNT
  333 FORMAT(1H , '***PARITY ERROR IN SUBR COPYOB WHILE READING FT',
     1       I2, 2X, '...INCOMPLETE OBSERV SET WITH ONLY ', I5,
     2       2X, 'ITEMS ***')
      IERROR = 5
      GO TO 999
C
  336 CONTINUE
C     ...COMES HERE IF PARITY ERROR AND NO INFO WAS COPIED...
      PRINT  339, LOBTAP
  339 FORMAT(1H , '***PARITY ERROR IN SUBR COPYOB WHILE READING FT',I2)
      IERROR = 3
      GO TO 999
C
  340 CONTINUE
C     ...COMES HERE IF END OF INFO.  IF SOME COPIED ASSUME NORMAL END
      IF(KOUNT .NE. 0) GO TO 344
      PRINT  342, LOBTAP
  342 FORMAT(1H , '*** ERROR. END OF DATA INDICATION IN COPYOB WHILE REA
     1DING FT', I2, 2X, ' ... NO PLOTTED OBS WERE COPIED *** ')
      IERROR = 4
      GO TO 999
  344 CONTINUE
      PRINT  348, NUMTRN,KOUNT
  348 FORMAT(1H , 20X, 'COMPLETED COPYING PLOTTED OBSERVATIONS AFTER TRA
     1NSFERRING ',I3, 2X, 'BINS TOTALLING ', I6, 2X, 'LABEL-ARRAY ITEMS'
     2 )
      GO TO 999
C     ...WHICH IS NORMAL EXIT .....
C
C     *     *     *     *     *     *     *     *     *     *     *
  360 CONTINUE
C     ...COMES HERE IF GOOD READ OF DATA BIN...
      PRINT *, ' 2 INBIN(1,1)=', INBIN(1,1)
      PRINT *, ' 2 INBIN(2,1)=', INBIN(2,1)
      PRINT 119,INBIN(1,1),INBIN(2,1)
      ITEMP = IAND(MSK0F, -7)
C     IF(INBIN(1,1) .NE. -7) GO TO 364
      IF(INBIN(1,1) .NE. ITEMP) GO TO 364
      ITEMP = IAND(MSK0F, LEND)
C     IF(INBIN(2,1) .EQ. LEND) GO TO 340
      IF(INBIN(2,1) .EQ. ITEMP) GO TO 340
  364 CONTINUE
      ITEMP = IAND(MSK0F, -1)
C     IF(INBIN(1,1) .NE. -1) GO TO 400
      IF(INBIN(1,1) .NE. ITEMP) GO TO 400
C     ...COMES HERE IF ID RECORD WAS READ BY MISTAKE
      PRINT  368, LOBTAP
  368 FORMAT(1H , '*** ERROR IN SUBR COPYOB.  READ AN  ID RECORD INSTEAD
     1 OF DATA RECORD *** ')
      GO TO 340
C
C     *     *     *     *     *     *     *     *     *     *     *
C      ...STEP(4) ... TO TRANSFER ITEMS FROM THE GOOD DATA BIN...
  400 CONTINUE
      NUMTRN = NUMTRN + 1
      DO  555 J = 1,LMAX
      IF(INBIN(1,J) .NE. 0) GO TO 405
      IF(INBIN(2,J) .EQ. 0) GO TO 340
C     ...WHICH TESTED FOR INTERNAL END OF INFO...
  405 CONTINUE
      IF(J .NE. 1) GO TO 410
      IF(NUMTRN .NE. 1) GO TO 410
C     ...OTHERWISE, IT,S THE FIRST WORD OF FIRST BIN WHICH IS INIT
      GO TO 555
C     ...WHICH SKIPS THE TRANSFER OF THE CHAR INITIALIZER ITEM
  410 CONTINUE
      LABIX = LABIX + 1
      IF(LABIX .LE. LMAX) GO TO 540
C     ...OTHERWISE, BUFFER OUT THE FULL LABEL BIN...
      PRINT  500
  500 FORMAT(1H , 'LABEL ARRAY FULL')
      NOBUF = NOBUF + 1
C     ...CHANGED FROM ASYNC WRITE 5/29/86 (DKM)...
#if defined (_BIG_ENDIAN)
      CALL SBYTES(INBUF,LABEL,0,32,0,2048)
#else
      CALL SBYTESCCS(INBUF,LABEL,0,32,0,2048)
#endif
C     WRITE(LBLTAP,ERR=503)LABEL
      PRINT *,' WRITE ONE RECORD TO TAPE55'
      WRITE(LBLTAP,ERR=503)INBUF
  505 CONTINUE
      LABIX = 1
      DO  506  I = 1,LMAX
      LABEL(1,I) = 0
      LABEL(2,I) = 0
  506 CONTINUE
  540 CONTINUE
      LABEL(1,LABIX) = INBIN(1,J)
      LABEL(2,LABIX) = INBIN(2,J)
      KOUNT = KOUNT + 1
  555 CONTINUE
C     ...WHEN IT FALLS THRU 555 LOOP, ONE INBIN IS DEPLETED...
      GO TO 320
C
C     *     *     *     *     *     *     *     *     *     *     *
C     ...ERROR EXITS ....
  503 CONTINUE
      PRINT  504,LBLTAP,NOBUF,LABIX
  504 FORMAT(1H0, 10X, 'ERROR STOP IN COPYOB WHILE WRITING ON FT',
     1       I2, /1H , 15X, 'NOBUF = ', I3, 5X, 'LABIX = ', I5)
      STOP 1816
C     ...CATASTROPHIC ERROR IF CAN,T WRITE ON TAPE55...
  810 CONTINUE
      PRINT  812,ILVLT
  812 FORMAT(1H , '*** ERROR RETURN FROM COPYOB.  GIVEN OUT-OF-RANGE ILV
     1LT = HEX ', Z8)
      IERROR = 1
      GO TO 999
  820 CONTINUE
      PRINT  822,KRUN1
  822 FORMAT(1H ,'*** ERROR RETURN FROM COPYOB.  GIVEN ',
     1   'OUT-OF-RANGE KRUN1 = HEX ',Z8)
      IERROR = 1
      GO TO 999
  910 CONTINUE
      PRINT  912, LOBTAP,NUMRED
  912 FORMAT(1H , '*** ERROR RETURN FROM COPYOB. END-OF-FILE WAS HIT WHI
     1LE SEARCHING FT', I2, 2X, 'FOR DESIRED PLOTTED OBS FILE ***',
     2 /1H , 20X, 'NUMBER OF RECORDS READ DURING SEARCH = ', I6)
      IERROR = 2
      GO TO 999
  920 CONTINUE
      PRINT  922,LOBTAP,NUMRED
  922 FORMAT(1H , '*** ERROR RETURN FROM COPYOB. PARITY ERROR WHILE SEAR
     1CHING FT', I2, 2X,'FOR DESIRED PLOTTED OBSERVATION FILE***',
     2 /1H , 20X, 'NUMBER OF RECORDS READ DURING SEARCH = ', I6)
      IERROR = 2
      GO TO 999
  930 CONTINUE
  940 CONTINUE
      PRINT  942, LOBTAP,NUMRED
  942 FORMAT(1H , '***ERROR RETURN FROM COPYOB.  LOGICAL END OF TAPE OR
     1 LOST ON SEARCH OF FT', I2, /1H , 20X, 'NUMBER OF RECORDS READ DUR
     2ING SEARCH IS ', I6)
      IERROR = 2
      GO TO 999
C
  999 CONTINUE
C
      REWIND LOBTAP
      print*,'Leaving copyob '
      RETURN
      END
ckumar
ckumar **************block data copyob_data
ckumar
      BLOCK DATA COPYOB_DATA
C
      INTEGER      MAXFONT
      PARAMETER   (MAXFONT=63)
      INTEGER LBLTAP
C
      COMMON /PUTWHERE/ LBLTAP,IERPUT,LCKPT_PUT,LCKPRNQQ,
     1                  IJPXL_GIVN(2),IJPXL_LBL(2),IJPXL_NEXCH(2),
     2                  NCALLS_PUT,ICOUNT_FONT(MAXFONT)
C
       DATA     LBLTAP/55/
C 
      END BLOCK DATA COPYOB_DATA
